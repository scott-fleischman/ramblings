Singleton types by themselves have no real value, and they also have no value when used as a components of product or list types. Since there is exactly one way to construct a singleton type, they can be constructed "out of thin air", so to speak. Since they're represented as `Fin 1`, there is only one possible value for them. Combining them in a product type means that the product of `S1 x S2` (where S1 and S2 are singleton types) is still represented as `Fin 1` because `1 * 1 = 1`. Likewise a `List S n` (where `S` is a singleton) for any length `n` will be represented as `Fin 1` because `1 ^ n = 1` for any `n`.

This corresponds to constructive logic because `top` is `truth` or `true` and truth is always true, so to speak, and our singletons are just `top`. Likewise `top x A` is isomorphic to `A`.

In our representation, a product of singleton types can be reduced to a singleton type, and a list of singletons can be reduced to a singleton. Perhaps the system should notify the user when constructing such a type that it is indistinguishable from a singleton type. I'm not sure if it should be an error, or whether the system could simply collapse such a type somehow. It's possible some computation may conclude with a product of singletons, in which case the computation could (and effectively would) collapse it because the representation collapses it.

Given the above, singleton types only acquire value by being part of a sum type. For example, a singleton type called `present` can be constructed at any type because it's equivalent to `true`. To give it meaning, we have to distinguish it from something, in this case `absent` or `not present`. But `absent` by itself has no meaning eitherâ€”it also is equivalent to `true`. It's only when we construct the sum type `present + absent` (where `+` represents the `or` of a sum type) that each singleton acquires value or meaning. We might call this type `presence` and definite it like `presence = present + absent`. Once you create a sum type, then only one of the options can be true. This leaves the other option to be false. In this case `presence = present + absent` will be represented as `Fin 2` because `2 = 1 + 1`.

The system might need to expose natural numbers as a primitive type since the `List` type needs it for its bounds. Although we don't want unbounded numbers, so the system may have `Fin n` as a primitive but it's not clear where the `n` should come in.

Also, a common scenario in serialization is that a serialized list of items is prefixed with the length of the list. It may be useful for this system to be a dependently-typed system so that we could write something along the lines of `(n : Fin max) x (List n)` to indicate a number along with a list of that length. Again, it's not clear what `max` should be here.

If natural numbers are meta-theoretic then we may also want to have data-driven meta-theoretic numbers. That way we can say something like `List A bound` where `bound` is determined by an actual data set. That would be something analogous to type providers, where we load data to compute at type at some stage in the process. Later stages would depend on that computation from actual data.
